\import Connection
\import Equiv
\import Iso
\import Proto
\import S1
\import Path
\import Univ

\data susp (A : \Type)
  | north
  | south
  | merid (a : A) (i : I) \elim i {
    | left => north
    | right => south
  }

\func S2 : \Type => susp S1

\func isContrSingl (A : \Type) (a : A) : isContr (singl A a) => ((a, (refl a)), (\lam (z : singl A a) => contr A a z.1 z.2))

\func idEquiv (A : \Type) : A <~> A => (\lam (x : A) => x, isContrSingl A)

\func Square {A : \Type} {a b c d : A}
             (u : a = b) (v : c = d) (p : a = c) (q : b = d)
  => Path (\lam i => u @ i = v @ i) p q

-- FFS, why couldn't it be as easy as function below?
\func reflSquare {A : \Type} {a : A} : Square (refl a) (refl a) (refl a) (refl a) => path (\lam i => (refl a))

\func constSquareBackAndForth {A : \Type} {a : A} (p : a = a) : Square (p # inv p) (p # inv p) (p # inv p) (p # inv p) => J C d p
  \where
    \func C {A : \Type} {a : A} : \Pi (x : A) -> a = x -> \Type =>
      \lam (x : A) =>
          \lam (q : a = x) =>
              Square (q # inv q) (q # inv q) (q # inv q) (q # inv q)
    \func d {A : \Type} {a : A} : constSquareBackAndForth.C a (refl a) => reflSquare

-- TODO
\func constSquare {A : \Type} {a : A} (p : a = a) : Path (\lam i => p @ i = p @ i) p p =>
  path (\lam i => coe (\lam _ => p @ i = p @ i) ((shrinkLeft p i) # (shrinkRight p i)) i)
    \where
      \func shrinkRight {A : \Type} {a : A} (p : a = a) (i : I) : a = p @ i => path (\lam j => p @ meet i j)
      \func shrinkLeft {A : \Type} {a : A} (p : a = a) (i : I) : p @ i = a => path (\lam j => p @ join i j)

\func rotation : \Pi (x : S1) -> base = base => \lam x => \case x \with {
  | base => loopS1
  | loop i => (constSquare loopS1) @ i
}

\func mu : S1 -> S1 <~> S1 => \lam x => \case x \with {
  | base => idEquiv S1
  | loop i => equivPath S1 S1 (idEquiv S1) (idEquiv S1) (path (\lam j =>  (x : S1) -> rotation x @ j)) @ i
}

\func H : S2 -> \Type => \lam x => \case x \with {
  | north => S1
  | south => S1
  | merid x i => Iso=>Path (\new Iso S1 S1 (mu x)) @ i
}

\record Hopf (p1 : S2) {
  \field f1 : H(p1)
}