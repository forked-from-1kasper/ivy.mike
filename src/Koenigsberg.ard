
\import Proto \import Path \import Equiv \import Int

\data Graph {A : \Type} (edges : A -> A -> \Type)
   | node (n : A)
   | line (n m : A) (condition : edges n m) (i : I) \elim i {
      | left => node n
      | right => node m
   }

\func isConnected {A : \Type} (edges : A -> A -> \Type)
   => \Pi (x y : A) -> either (edges x y) (edges y x)

\func isAcyclic {A : \Type} (edges : A -> A -> \Type)
   => K (Graph edges)

\func isCycle {A : \Type} {edges : A -> A -> \Type} {a : Graph edges} (p : a = a)
   => p =/= rfl

\func isNotEulerian {A : \Type} {edges : A -> A -> \Type} {a b : Graph edges} (p : a = b)
   => \Sigma (c : Graph edges) (q : a = c) (r : c = b) (loop : c = c)
      (loop-is-cycle : isCycle loop) (q # loop # r = p)

\func isPathCover {A : \Type} {edges : A -> A -> \Type} {a b : Graph edges}
   (p : a = b) (c : Graph edges)
   => \Sigma (q : a = c) (r : c = b) (q # r = p)

\func coverAll {A : \Type} {edges : A -> A -> \Type} {a b : Graph edges} (p : a = b)
   => \Pi (x : Graph edges) -> isPathCover p x

\data Koenigsberg
   | Altstadt
   | Kneiphof
   | Lomse
   | Vorstadt

\func Koenigsberg-edges (n m : Koenigsberg) : \Type \elim n, m
   | Kneiphof, Lomse => unit
   | Altstadt, Lomse => unit
   | Lomse, Vorstadt => unit
   | Altstadt, Kneiphof => bool
   | Altstadt, Vorstadt => bool
   | _, _ => empty

\func Koenigsberg-statement (area : Graph Koenigsberg-edges)
   => \Pi (p : area = area) -> coverAll p -> isCycle p -> isNotEulerian p